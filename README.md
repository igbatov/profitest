# profitest
Алгоритм для выделения из произвольной строки телефонных номеров. 

Однозначно вытащить номера в общем случае из произвольной строки невозможно. Например, однозначно
разбить строку "905 45 56 905 123 45 67" на 2 телефонных номера нельзя.
Еще сложнее обстоит дело со строкой "Звоните с 9 до 16 на 727 00 16 доб 220 а после 16 на 232 33 71#3"

В этом случае можно действовать двумя способами.
Либо сделать жесткий алгоритм который будет выдавать телефоны только если из строки можно однозначно выделить
соответствующие номера.
Либо выдавать все варианты которые можно вынуть из этой строки, даже если среди них будет много не верных.

В первом случае мы будем откидывать много вариантов строк в которых нельзя однозначно разобраться. 
Во втором случае большинство номеров выдаваемых алгоритмом будут ошибочными, 
хотя мы будем знать что и правильный точно есть среди них.  

Какой подход выбрать - зависит от задачи. Если, например, нужно автоматически перезванивать человеку,
то лучше выбрать первый, а все строки в которых мы не смогли распарсить отсылать операторы для ручной обработки.

Если же мы хотим просто выдавать оператору список клиентов похожих на того от кого пришел запрос, то лучше второй
варинат.

Для первого алгоритма зададим слудеющие условия. Он будет обрабатывать только строки в которых пользователь ввел
один или несколько номеров разделенных "," или ";". Внутри самого номера допускаем только пробел и символы "-", "(", ")".
Строки вида "222-11-00 доб. 32" или сложнее мы уже парсить не будем.
Скорее всего этот правила будут закрывать около 90% случаев

Этот алгорит реализован в PhoneProcess::strictParse.

Второй, жажный, алгоритм 
- Заменяем все нецифры на пробелы, получаем массив чисел котрые раздалены одним или несколькими пробелами.
- Считаем что подпоследовательность идущих подряд в этом массиве чисел является телефонным номером, если длина
подпоследовательности равна 7, 10 или 11

Релизация - PhoneProcess::greedyParse

Для проверки разных строк удобно использовать тесты из PhoneProcessTest.php

Итого, для задачи определения заказов от того же номера.
- Получаем строку, проверяем что она не слишком длинная, экранируем её и сохраняем в базу, в необработанном виде.
Оператор в любом случае должен её увидеть, там может быть ценная информация.
- Выделяем из строки номера с помощью strictParse или greedyParse. Что на практике лучше работает мы узнаем попробовав на бою оба.
- Делаем запрос в БД чтобы вынуть все заказы, похожие на этот по номеру телефона.

Организация БД.
Будем хранить в виде трех таблиц - таблица номеров, таблица пользователей, таблица заказов пользователей.
Номера и заказы ссылаются на пользователей.
Вынимать заказы по номерам можно запросом: 
SELECT id, value FROM order WHERE client_id IN (SELECT client_id FROM phone WHERE value IN ('89035432211', ...))
Возможно запрос будет быстрее если вместо IN использовать JOIN по временной таблице с 
телефонными номерами из IN ('89035432211', ...)
Насколько я помню это зависит от БД и её версии.

Определения таблиц.
CREATE TABLE `client` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255),
  PRIMARY KEY (`id`),
  FULLTEXT KEY `client` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8

CREATE TABLE `phone` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `value` varchar(255),
  `client_id` int(11),
  PRIMARY KEY (`id`),
  KEY `value_idx` (`value`)
  KEY `client_id_idx` (`client_id`),
) ENGINE=InnoDB DEFAULT CHARSET=utf8

CREATE TABLE `order` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `value` TEXT,
  `client_id` int(11),
  PRIMARY KEY (`id`),
  KEY `client_id_idx` (`client_id`),
) ENGINE=InnoDB DEFAULT CHARSET=utf8